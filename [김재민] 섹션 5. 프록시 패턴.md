## 프록시 패턴에 들어가기 앞서

### 클라이언트와 서버
- 클라이언트 : 서버에 필요한 것을 요청
- 서버 : 클라이언트의 요청을 처리

### 직접 호출과 간접 호출
- 직접 호출 : 클라이언트가 서버를 직접 호출하고, 처리 결과를 직접 받는 것
- 간접 호출 : 클라이언트가 서버에 직접 요청하는 것이 아닌 대리자를 통해서 간접적으로 서버에 요청
  - 여기서 대리자를 프록시(Proxy)라고 한다.

### 프록시의 주요 기능
- 접근 제어
  - 권한에 따른 접근 차단
  - 캐싱
  - 지연 로딩
- 부가 기능 추가
  - 원래 서버가 제공하는 기능에 더해서 부가 기능 수행

> GOF 디자인 패턴에서의 프록시 패턴은 프록시를 사용해서 프록시 패턴이라기 보다는 <br/> 접근 제어의 목적으로 프록시를 사용하는 것을 프록시 패턴이라고 한다.

---

## 프록시 패턴

### 접근 제어
- 대표적인 접근 제어로는 캐시가 있다.
  - 데이터가 한번 조회하면 변하지 않는 데이터일 때, 이미 조회한 데이터를 사용하는 것

### 프록시 패턴 적용 전
![1-1](https://github.com/user-attachments/assets/4ebe2407-e954-42bc-b548-30b24f946134)

![2](https://github.com/user-attachments/assets/e6539a66-a8f6-4a51-83cf-e0143db0237d)

<br />

### 프록시 패턴 적용 후
![3](https://github.com/user-attachments/assets/21b2c0ba-fb7a-4b89-a190-e300a93c50a1)

![4](https://github.com/user-attachments/assets/bdaf5349-2a62-4459-a3e0-07d0d6eb6d2f)

<br />

``` java
@Slf4j
public class CacheProxy implements Subject{

    private Subject target;
    private String cacheValue;

    public CacheProxy(Subject target) {
        this.target = target;
    }

    @Override
    public String operation() {
        if (cacheValue == null) {
            cacheValue = target.operation();
        }
        return cacheValue;
    }
}
```
- `target` : 프록시가 호출하는 대상
- `client`에 `realSubject`가 아닌 `cacheProxy`를 주입
  - `client -> cacheProxy -> realSubject` 런타임 객체 의존 관계가 완성

1. client의 cacheProxy 호출 → cacheProxy에 캐시 값이 없다. → realSubject를 호출, 결과를 캐시에 저장(1초)
2. client의 cacheProxy 호출 → cacheProxy에 캐시 값이 있다. → cacheProxy에서 즉시 반환(0초)
3. client의 cacheProxy 호출 → cacheProxy에 캐시 값이 있다. → cacheProxy에서 즉시 반환(0초)

결과적으로 도입 전에는 3초가 걸리는 일이 약 1초로 줄어들게 된다.

---

## 생각 정리


**좋은 설계는 변하는 것과 변하지 않는 것을 분리하는 것이다.** (김영한 피셜)

이를 통해 유지보수가 쉬운 구조를 만들고, 변경사항이 자연스럽게 드러나도록 설계해야 한다. 이를 실현하기 위한 디자인 패턴 중 하나가 바로 **템플릿 메서드 패턴**이다.

---

## 템플릿 메서드 패턴?

템플릿 메서드 패턴은 **알고리즘의 골격을 정의한 다음, 일부 단계를 하위 클래스에서 구현할 수 있도록 하는 디자인 패턴**이다.  
즉, 변하지 않는 부분은 부모 클래스에 두고, 변하는 부분은 하위 클래스에서 구현한다.

- 템플릿 메서드 패턴은 **상속**이라는 기술을 극대화하여 사용하는 디자인 패턴이다.
- 알고리즘의 뼈대를 맞추는 것에 초점을 두며, 이미 많은 프레임워크에서 활용되고 있다.
- 상속과 오버라이딩을 통한 다형성으로 문제를 해결하는 패턴이다.

---

## 템플릿 메서드 패턴의 구조

1. **추상 클래스**  
   알고리즘의 골격이 되는 템플릿 메서드를 정의하며, 변하지 않는 부분을 구현한다.  
   변하는 부분은 추상 메서드로 선언한다.

2. **템플릿 메서드**  
   알고리즘의 전체 흐름을 정의하는 메서드이다.  
   추상 메서드(또는 Hook 메서드)를 호출하여 하위 클래스의 구체적인 구현을 포함한다.

3. **하위 클래스**  
   부모 클래스의 추상 메서드를 구현하여 알고리즘의 특정 단계를 정의한다.

---

## 템플릿 메서드 패턴의 특징

### 사용 시점
- 알고리즘의 특정 단계만 확장하면서도 전체 구조는 유지해야 할 때.
- 공통된 기능은 상위 클래스에 두고, 변화가 필요한 부분만 하위 클래스에서 구현해야 할 때.

### 장점
1. **코드 중복 감소**  
   상위 클래스에서 공통된 로직을 처리하기 때문에 코드 중복을 줄일 수 있다.

2. **유지보수 용이**  
   알고리즘의 핵심 로직을 한곳에서 관리하므로 수정이 용이하다.

3. **확장성 확보**  
   하위 클래스에서 특정 단계만 재정의할 수 있어 전체 구조를 변경하지 않고도 기능을 확장할 수 있다.

### 단점
1. **유연성 제한**  
   알고리즘의 뼈대가 상위 클래스에 고정되기 때문에 구조가 복잡해질수록 유지보수가 어려울 수 있다.

2. **상속의 한계**  
   하위 클래스는 상위 클래스에 강하게 결합된다.  
   상위 클래스를 수정하면 모든 하위 클래스가 영향을 받을 수 있다.

3. **추상 메서드의 관리 부담**  
   상위 클래스에 많은 추상 메서드가 추가되면 하위 클래스에서 구현해야 할 내용이 증가하여 관리가 복잡해질 수 있다.

---

## 템플릿 메서드 패턴과 전략 패턴의 비교

| 템플릿 메서드 패턴                          | 전략 패턴                          |
|---------------------------------------------|------------------------------------|
| 상속을 기반으로 알고리즘의 구조를 정의한다. | Composition을 기반으로 알고리즘을 동적으로 변경할 수 있다. |
| 알고리즘 구조를 고정적으로 사용해야 할 때 적합하다. | 유연한 알고리즘 변경이 필요할 때 유리하다. |

---

## 템플릿 메서드 패턴의 예시

### 스프링 프레임워크
- **`WebSecurityConfigurerAdapter`**  
  `configure()` 메서드를 오버라이드하여 보안 설정을 정의한다.
- **`AbstractController`**  
  템플릿 메서드를 통해 공통 로직을 처리하고, 세부 동작을 하위 클래스에서 구현한다.

### 자바 표준 라이브러리
- **`java.io.InputStream` 및 `OutputStream`**  
  하위 클래스가 읽기/쓰기 로직을 재정의한다.
- **`java.util.AbstractList`**  
  리스트의 구조는 유지하면서 구체적인 동작을 재정의한다.

### 서블릿
- **`HttpServlet`**  
  `doGet()`, `doPost()` 메서드를 하위 클래스에서 재정의하여 요청 처리를 구현한다.

---

## ❗️ 템플릿 메서드 패턴은 SRP에 부합할까?

템플릿 메서드 패턴은 언뜻보면 SRP(단일책임 원칙)에 부합해보이지만, 설계 방식에 따라 애매해질 수 있는 부분이 존재한다.

### 단일 책임 원칙(SRP)
- **정의:** 클래스는 하나의 책임만 가져야 한다. 즉, 클래스는 하나의 변경 이유만 가져야 한다.
- **목적:** 클래스가 지나치게 많은 역할을 가지는 것을 방지하여, 유지보수와 확장을 용이하게 한다.

---

### 템플릿 메서드 패턴이 SRP에 부합한 면모

1. **변경 이유의 분리**
    - 상위 클래스는 알고리즘의 전체적인 흐름에만 책임을 진다.
    - 하위 클래스는 변해야 할 구체적인 동작(변하는 부분)에만 책임을 진다.

2. **중복 제거와 책임 집중**
    - 공통적인 로직은 상위 클래스에서 관리하며, 중복된 구현이 제거된다.

3. **확장에 따른 책임 분리**
    - 새로운 세부 동작이 추가되더라도 하위 클래스를 추가하는 방식으로 변경사항을 격리할 수 있다.




### SRP에 부합하지 않을 수 있는 경우

1. **상위 클래스에 과도한 책임 집중**  
   상위 클래스에 너무 많은 템플릿 메서드와 추상 메서드가 포함되면, 상위 클래스가 다양한 세부 동작의 관리 책임까지 가지게 된다.

2. **추상 메서드의 관리 부담**  
   추상 메서드가 많아지면 하위 클래스는 상위 클래스의 구조를 이해하고 따라야 한다.

3. **잘못된 역할 분리**  
   상위 클래스가 지나치게 많은 공통 로직을 관리하면 SRP 원칙을 위반하게 된다.

---


템플릿 메서드 패턴은 SRP 원칙에 대체로 부합한다. 특히, 공통 로직(변하지 않는 부분)과 세부 구현(변하는 부분)을 명확히 분리함으로써 책임을 나누는 데 유리하다.  
그러나 설계가 복잡하거나, 상위 클래스에 과도한 책임이 집중되면 SRP는 지켜지지 않는다.

템플릿 메서드 패턴을 적용할 때는 상위 클래스와 하위 클래스 간의 책임을 명확히 분리하고, 설계를 단순하게 유지하는 것이 중요하다.

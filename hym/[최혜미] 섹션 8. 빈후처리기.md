# 빈 후처리기(BeanPostProcessor)

## 1. 빈 후처리기란?
빈 후처리기는 스프링이 제공하는 후킹 포인트. 스프링 빈이 등록되기 전에 객체를 조작하거나 다른 객체로 교체할 수 있는 강력한 메커니즘이다.

### 빈 후처리기의 사용 목적
- 원본 코드를 변경하지 않고 부가 기능을 추가할 수 있다.
- 객체를 프록시로 대체하여 특정 로직을 삽입할 수 있다.
- 등록 직전 빈 객체의 구조를 변경할 수 있다.

### 빈 후처리기의 작동 과정
1. **생성**: @Bean이나 컴포넌트 스캔으로 빈 대상 객체를 생성한다.
2. **전달**: 생성된 객체가 빈 저장소에 등록되기 직전에 빈 후처리기에 전달된다.
3. **후처리**: 전달된 객체를 조작하거나 다른 객체로 바꿔치기할 수 있다.
4. **등록**: 최종 객체를 반환하여 빈 저장소에 등록된다.

---

## 2. 빈 후처리기와 프록시 생성
프록시는 원본 객체를 감싸는 대리 객체로, 메서드 호출 시 부가 기능을 삽입하는 데 사용된다. 빈 후처리기를 통해 생성된 객체를 프록시로 대체하면 부가 기능(Advice)을 삽입할 수 있다. 이 방식은 원본 객체를 변경하지 않으면서도 스프링 컨테이너에 프록시 객체가 등록되므로 애플리케이션에서는 투명하게 동작한다.

---

## 3. 자동 프록시 생성기(Spring에서의 빈후처리기)
스프링은 `AnnotationAwareAspectAutoProxyCreator`라는 자동 프록시 생성기를 통해 Advisor를 기반으로 필요한 빈에만 프록시를 생성한다.

### 자동 프록시 생성기의 작동 과정
1. **스프링 빈 생성**: @Bean 또는 컴포넌트 스캔으로 빈을 생성한다.
2. **빈 후처리기로 전달**: 빈 등록 전에 자동 프록시 생성기로 전달된다.
3. **Advisor 조회**: 스프링 컨테이너에서 모든 Advisor를 조회한다.
4. **프록시 적용 대상 판단**: Pointcut을 기반으로 프록시가 필요한 빈인지 판단한다.
5. **프록시 생성 및 반환**: 프록시를 생성 후 반환하여 스프링 빈으로 등록한다.

### Pointcut의 역할
1. **프록시 생성 여부 판단**: 빈 등록 시 해당 객체가 프록시 대상인지 검사한다.
2. **어드바이스 적용 여부 판단**: 프록시 메서드 호출 시 부가 기능 실행 여부를 결정한다.

---

## 4. 모든 빈에 프록시를 생성하면 안되는 이유
강의에서는 모든 곳에 프록시를 생성하는 것은 비용낭비라고 언급했다.

그렇기 때문에 스프링 빈후처리기는 Pointcut으로 한 번 필터링하여 Advice가 사용될 가능성이 있는 곳에만 프록시를 생성하는데, 이에 대해 자세히 알아보고자 한다. 
### 모든 빈에 프록시 생성의 문제점
- 불필요한 객체 생성으로 인해 메모리 사용량이 증가한다.
- 메서드 호출 시 프록시를 거치므로 성능이 저하된다.
- 관리 복잡성이 증가한다.

### 해결 : 자동 프록시 생성기 최적화
- Pointcut으로 필터링하여 부가 기능이 필요 없는 빈에는 프록시를 생성하지 않는다.
- 하나의 프록시에 여러 Advisor를 포함하여 중복 프록시 생성을 방지한다.
   - 즉, 하나의 스프링빈에 여러 advisor의 Pointcut조건을 만족하여도 프록시 자동 생성기는 프록시를 하나만 생성한다.
   - cause 프록시 팩토리가 생성하는 프록시는 내부에 여러 advisor들을 포함할 수 있기 때문

---

## 5. AspectJExpressionPointcut
`AspectJExpressionPointcut`은 복잡하고 정밀한 조건을 설정하여 포인트컷을 작성할 수 있다. 클래스 이름, 메서드 이름, 패키지 경로 등 세부적인 필터링이 가능하다.

(상세 내용은 뒤에서 언급될 예정)

### AspectJExpressionPointcut의 효과
- 특정 메서드에만 정확히 어드바이스를 적용할 수 있다.
- 부가 기능이 필요 없는 빈과 메서드는 배제하여 성능을 최적화할 수 있다.

---

# ❗️ 프록시를 생성하면 왜 비용 낭비인가?

### 1. 메모리 및 성능 문제
- 프록시는 원본 객체를 감싸는 대리 객체로, 각 객체마다 별도 메모리가 사용된다.
- 모든 빈에 프록시를 생성하면 메모리 사용량이 과도하게 증가하며 GC 부하가 증가한다.
- 프록시를 거치는 호출 구조로 인해 성능 저하가 발생한다.

### 2. 불필요한 생성
- 부가 기능이 필요 없는 빈에 프록시를 생성하면 객체 관리 복잡성이 증가하고 성능도 불필요하게 저하된다.

### 💡 해결책: 
#### 정밀한 포인트컷
- 포인트컷을 사용하여 부가 기능이 필요 없는 빈과 메서드는 배제한다.
- 예를 들어 패키지, 클래스, 메서드 조건을 설정하여 프록시를 생성할 대상을 필터링한다.

#### 프록시 재사용
- 동일한 객체에 대해 여러 Advisor가 필요해도 하나의 프록시만 생성된다.
- 하나의 프록시에 여러 Advisor를 포함하면 추가 비용 없이 다양한 부가 기능을 적용할 수 있다.

> ## 💡 왜 GC의 부하가 증가할까?
> ### 1. 객체 생성 수 증가
> 프록시는 원본 객체를 감싸는 래퍼 객체로, 원본 객체 외에 별도의 메모리를 차지한다. 스프링 애플리케이션에서 프록시가 많이 생성될수록 JVM 힙 메모리에 더 많은 객체가 할당된다. <br>
> - **영역 문제:** 대부분의 프록시는 비교적 짧은 수명을 가지는 영(Young) 영역에 생성된다.<br>
> - **GC 빈도 증가:** 영 영역은 가비지 컬렉션이 자주 발생하므로, 많은 프록시가 생성되고 제거되면 GC의 빈도와 작업량이 증가하게 된다.
> ### 2. 메모리 누수 위험 증가
> 프록시 객체는 일반 객체보다 복잡한 구조를 가지며, 내부적으로 메타데이터와 참조를 유지한다. 잘못 관리되면 이러한 참조가 GC의 수거 대상이 되지 않아 메모리 누수로 이어질 가능성이 있다.
> - 프록시 객체는 원본 객체에 대한 강한 참조를 유지하므로, 애플리케이션의 특정 조건에서 원본 객체의 생명주기를 필요 이상으로 연장할 수도 있다.
> - 특히, 전역 스코프(Spring의 singleton 스코프)로 등록된 빈의 경우, 의도치 않게 메모리가 점유된 상태로 남을 수 있다.
> ### 3. 프록시의 추가 메모리 사용
>   프록시는 원본 객체에 대한 대리자 역할을 하므로 다음과 같은 추가 리소스를 사용한다
> - **메타데이터 저장:** 프록시 내부에는 원본 객체 참조, 인터페이스 구현 정보, Advice 및 Pointcut 관련 메타데이터가 저장된다.
> - **메서드 호출 관리:** 메서드 호출이 프록시를 거칠 때마다 MethodInvocation 객체를 생성하여 어드바이스 체인을 관리한다. 이런 메서드 호출이 많아지면 일시적으로 생성되는 객체의 수도 증가한다.
> ### 4. GC 처리량 증가
>   프록시를 과도하게 생성하면 일시적인 객체가 늘어나고, 이 객체들이 살아남아 영 영역에서 Old 영역으로 승격될 가능성도 높아진다. 구역 영역으로 올라간 객체는 더 복잡한 GC 과정을 거쳐야 하므로, 애플리케이션의 응답 속도가 저하될 수 있다.
> ### 5. GC의 병목 현상
>   프록시로 인해 생성된 많은 객체가 힙 메모리를 차지하면 GC가 이를 정리하기 위해 점점 더 많은 시간을 소비하게 된다. 결과적으로 GC가 병목 현상을 일으켜 애플리케이션의 전반적인 성능에 부정적인 영향을 미친다.
